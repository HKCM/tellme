---
tags: ["缓存击穿"]
---
# 缓存击穿
---
## 缓存击穿

也叫热点Key问题，是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力

### 示例分析

假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了.

假设在线程1没有走完的时候，后续线程2，线程3，线程4同时过来访问同一个数据, 在线程1没完成的情况下缓存未命中，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大

常见的解决方案有两种:
- 热点key永不过期
- 逻辑过期,把过期时间设置在redis的value中通过业务逻辑判断是否过期，如果过期则通过新的子线程去数据库查询更新
- 互斥锁,采用tryLock方法 + double check来防止并发访问数据库
- 接口限流与熔断，降级,防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制

方案对比:
- 永不过期可能占内存
- 逻辑过期和永不过期实质是一样的,但是具有检查功能
- 互斥锁方案:由于保证了互斥性，所以数据一致，实现简单，仅需加一把锁,没有额外的内存消耗，缺点在于可能存在死锁问题，且只能串行执行性能受到影响
